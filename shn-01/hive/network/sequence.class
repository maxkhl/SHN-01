--[[
    SHN-01 Network Sequence Class
        This class represents a network sequence in the SHN-01 system.
        It handles the execution and management of sequences based on manifests.
        A sequence is a dialogue between two networked systems following a predefined set of steps.
]]
local sequence = newClass()


sequence.sequenceStatus = {
    initialized = 1,
    started = 2,
    timedout = 3,
    error = 4,
    finished = 5,
}

-- Creates a new sequence object based on the manifest and mode
function sequence:create(manifestPath, serverMode, ...)
    assert(manifestPath, "No manifest path given")
    
    local manifest = include(manifestPath)
    assert(manifest, "Could not load manifest from " .. manifestPath)

    assert(manifest.name, "Manifest has no name")
    assert(manifest.serverClass or manifest.clientClass, "Manifest has no server or client class defined")
    assert(serverMode, "Invalid serverMode mode, expected true for server, false for client")
    assert(type(serverMode) == "boolean", "Invalid serverMode mode, expected boolean")
    assert(self, "Must be called on a object")
    local sequenceClass = nil
    if serverMode and manifest.serverClass then
        sequenceClass = class(getAbsolutePath(manifest.serverClass, file.getDir(manifestPath)))
        assert(sequenceClass, "No sequence class found for server mode " .. manifest.name)
    elseif not serverMode and manifest.clientClass then
        sequenceClass = class(getAbsolutePath(manifest.clientClass, file.getDir(manifestPath)))
        assert(sequenceClass, "No sequence class found for client mode " .. manifest.name)
    else
        error("Sequence manifest " .. manifest.name .. " no valid mode")
    end    
    return sequenceClass:new(...)
end

function sequence:constructor(name, func, timeout, timeoutCallback)
    assert(name, "No sequence name given")
    assert(func, "No sequence function given")
    assert(type(func) == "function", "Invalid sequence function, expected function")
    assert(self, "Must be called on a object")
    assert(timeoutCallback == nil or type(timeoutCallback) == "function", "Invalid timeout function, expected function or nil")

    self.name = name
    self.id = crypto.sessionID() -- Unique ID for the sequence
    self.status = sequence.sequenceStatus.initialized
    self.routine = coroutine.create(func)
    self.startTime = os.time()
    self.timeout = timeout or 60 -- Default timeout of 60 seconds
    self.timeoutCallback = timeoutCallback
    self.result = nil -- Result returned by the sequence when finished
    self.alive = true

end

function sequence:__tostring()
    self:assert(self, "Must be called on a object")
    return string.format("<c=0xFFFF00>[%s]</c> <c=0xFF00FF>%s</c>", self.name:upper(), self.id)
end

function sequence:checkTimeout()
    self:assert(self, "Must be called on a object")
    if os.time() - self.startTime > self.timeout then
        self.status = sequence.sequenceStatus.timedout
        if self.timeoutCallback then
            self.timeoutCallback(self.id)
        end
        return true
    end
    return false
end

-- Handles an error in the sequence
function sequence:error(msg)
    assert(self, "Must be called on a object")
    self.status = sequence.sequenceStatus.error
    self.alive = false
    error("Sequence " .. tostring(self) .. " error: " .. tostring(msg))
end

-- Asserts a condition in the sequence
function sequence:assert(cond, msg)
    assert(self, "Must be called on a object")
    if not cond then
        self:error(msg)
    end
end

-- Processes a message in the sequence
function sequence:process(message)
    self:assert(self, "Must be called on a object")
    self:assert(not self:checkTimeout(), "Sequence has timed out")
    self:assert(message, "No message given")

    -- Resume the sequence coroutine with the incoming message. Use pcall to catch errors.
    -- IMPORTANT: this implementation strictly assumes the coroutine returns a single TABLE
    -- containing outbound message objects (nothing else). We enforce that here.
    local results = {pcall(coroutine.resume, self.routine, message)}
    if not results[1] then
        self:error("Error resuming coroutine in " .. tostring(self) .. ": " .. tostring(results[2]))
    end
    if not results[2] then
        self:error("Coroutine error in " .. tostring(self) .. ": " .. tostring(results[3]))
    end

    -- Expect a single table as the coroutine return (at results[3]).
    local outbound = results[3]
    if type(outbound) ~= "table" then
        self:error("Expected coroutine to return a table of outbound messages, got " .. tostring(outbound))
    end

    -- Send every outbound message returned by the coroutine. Use ipairs to iterate
    -- the table in order and skip any nil/holes automatically.
    for _, msg in ipairs(outbound) do
        if not isInstanceOf(msg, class("messages/outbound")) then
            self:error("Expected outbound instance from sequence return, got " .. tostring(msg))
        end
        if type(msg.send) ~= "function" then
            self:error("Outbound message has no send() method to deliver it")
        end
    end

    -- If coroutine finished, mark sequence finished and keep returned result for inspection.
    if coroutine.status(self.routine) == "dead" then
        self.status = sequence.sequenceStatus.finished
        self.result = outbound
        self.alive = false
    end

    -- Keep the returned table for inspection and return it to the caller.
    self.result = outbound
    -- If coroutine finished, mark sequence finished.
    if coroutine.status(self.routine) == "dead" then
        self.status = sequence.sequenceStatus.finished
        self.alive = false
    end

    return outbound
end

return sequence