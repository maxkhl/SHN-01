--[[
    SHN-01 Network Sequence Class
        This class represents a network sequence in the SHN-01 system.
        It handles the execution and management of sequences based on manifests.
        A sequence is a dialogue between two networked systems following a predefined set of steps.
]]
local sequence = newClass()

-- Creates a new sequence object based on the manifest and mode
-- This is a static factory method - call as: sequenceClass.create(hive, protocol, manifestPath, serverMode)
function sequence.create(hive, protocol, manifestPath, serverMode, ...)
    assert(manifestPath, "No manifest path given")
    
    local manifest = include(manifestPath)
    assert(manifest, "Could not load manifest from " .. manifestPath)

    assert(manifest.name, "Manifest has no name")
    assert(manifest.server or manifest.client, "Manifest has no server or client defined")
    assert(serverMode ~= nil, "Invalid serverMode mode, expected true for server, false for client")
    assert(type(serverMode) == "boolean", "Invalid serverMode mode, expected boolean")
    
    local sequenceFuncFactory = nil
    if serverMode and manifest.server then
        sequenceFuncFactory = include(getAbsolutePath(manifest.server, file.getDir(manifestPath)))
        assert(sequenceFuncFactory, "No sequence function found for server mode " .. manifest.name)
        assert(type(sequenceFuncFactory) == "function", "Expected sequence function factory, got " .. type(sequenceFuncFactory))
    elseif not serverMode and manifest.client then
        sequenceFuncFactory = include(getAbsolutePath(manifest.client, file.getDir(manifestPath)))
        assert(sequenceFuncFactory, "No sequence function found for client mode " .. manifest.name)
        assert(type(sequenceFuncFactory) == "function", "Expected sequence function factory, got " .. type(sequenceFuncFactory))
    else
        error("Sequence manifest " .. manifest.name .. " no valid mode")
    end
    
    -- Call the factory function to get the actual coroutine function
    -- Server functions receive hive and protocol, client functions receive nothing
    local sequenceFunc = nil
    if serverMode then
        sequenceFunc = sequenceFuncFactory(hive, protocol)
    else
        sequenceFunc = sequenceFuncFactory()
    end
    assert(type(sequenceFunc) == "function", "Expected sequence function from factory, got " .. type(sequenceFunc))
    
    -- Create sequence instance with the function
    local instance = sequence:new(
        manifest.name,
        sequenceFunc,
        manifest.timeout,
        manifest.timeoutCallback
    )
    return instance
end

function sequence:constructor(name, func, timeout, timeoutCallback)
    assert(name, "No sequence name given")
    assert(func, "No sequence function given")
    assert(type(func) == "function", "Invalid sequence function, expected function")
    assert(self, "Must be called on a object")
    assert(timeoutCallback == nil or type(timeoutCallback) == "function", "Invalid timeout function, expected function or nil")

    self.name = name
    self.func = func
    self.timeout = timeout or 60 -- Default timeout of 60 seconds
    self.timeoutCallback = timeoutCallback
    self.sessions = {} -- Each session has its own coroutine and state

end

-- Creates a new session for this sequence and processes the first message
function sequence:createSession(firstMessage)
    self:assert(self, "Must be called on a object")
    
    -- Generate session ID with collision detection
    local sessionId = crypto.sessionID()
    local maxRetries = 10
    local retryCount = 0
    
    -- Check for collisions across all protocols and sequences
    local function isSessionIdUsed(id)
        if not server or not server.protocols then
            return false
        end
        
        for _, protocol in pairs(server.protocols) do
            if protocol.sequences then
                for _, seq in pairs(protocol.sequences) do
                    if seq.sessions then
                        for _, session in ipairs(seq.sessions) do
                            if session.id == id then
                                return true
                            end
                        end
                    end
                end
            end
        end
        return false
    end
    
    -- Regenerate ID if collision detected
    while isSessionIdUsed(sessionId) and retryCount < maxRetries do
        debugPrint("<c=0xFF0000>Session ID collision detected: " .. sessionId .. "</c>, regenerating...")
        sessionId = crypto.sessionID()
        retryCount = retryCount + 1
    end
    
    if retryCount >= maxRetries then
        error("Failed to generate unique session ID after " .. maxRetries .. " attempts")
    end
    
    local newSession = {
        id = sessionId,
        routine = coroutine.create(self.func),
        startTime = computer.uptime(),
        result = nil,
        nodeAddress = firstMessage.remoteAddress  -- Track which node this session belongs to
    }
    table.insert(self.sessions, newSession)
    
    -- Register session with the node for efficient cleanup
    if firstMessage.node then
        firstMessage.node.sessions[newSession.id] = true
    end
    
    -- Send SESSION_CREATED notification to client
    if firstMessage.node then
        -- Use outbound message class when node exists
        local sessionNotification = class("messages/outbound"):new(
            firstMessage.node,
            firstMessage.protocol,
            firstMessage.distance,
            "SESSION_CREATED",
            newSession.id
        )
        sessionNotification:send()
    else
        -- Send directly via modem when node doesn't exist yet (e.g., during handshake)
        local modem = getComponent("modem")
        modem.send(firstMessage.remoteAddress, firstMessage.protocol.port, "SESSION_CREATED", newSession.id)
    end
    
    -- Process the first message to kick off the session
    self:process(newSession.id, firstMessage)
    
    return newSession.id
end

-- Finds a session by its ID
function sequence:findSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for _, session in ipairs(self.sessions) do
        if session.id == sessionID then
            return session
        end
    end
    return nil
end

-- Removes a session by its ID
function sequence:removeSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for i, session in ipairs(self.sessions) do
        if session.id == sessionID then
            -- Remove from node's session registry
            if server and server.nodes and server.nodes[session.nodeAddress] then
                local node = server.nodes[session.nodeAddress]
                if node.sessions then
                    node.sessions[sessionID] = nil
                end
            end
            table.remove(self.sessions, i)
            return true
        end
    end
    return false
end

-- Gets all active sessions
function sequence:getActiveSessions()
    self:assert(self, "Must be called on a object")
    
    local active = {}
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            table.insert(active, session)
        end
    end
    return active
end

-- Gets the count of sessions (total and active)
function sequence:getSessionCount()
    self:assert(self, "Must be called on a object")
    
    local total = #self.sessions
    local active = 0
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            active = active + 1
        end
    end
    return total, active
end

function sequence:__tostring()
    self:assert(self, "Must be called on a object")
    return string.format("<c=0xFFFF00>[%s]</c>", self.name:upper())
end

function sequence:checkTimeout(session)
    self:assert(self, "Must be called on a object")
    self:assert(session, "No session given")
    
    -- Skip timeout check if timeout is 0 (indefinite session)
    if self.timeout and self.timeout > 0 and computer.uptime() - session.startTime > self.timeout then
        if self.timeoutCallback then
            self.timeoutCallback(session.id)
        end
        self:removeSession(session.id)
        return true
    end
    return false
end

-- Checks all sessions for timeouts and removes timed-out sessions
function sequence:checkTimeouts()
    self:assert(self, "Must be called on a object")
    
    -- Iterate backwards to safely remove during iteration
    for i = #self.sessions, 1, -1 do
        local session = self.sessions[i]
        self:checkTimeout(session)
    end
end

-- Handles an error in the sequence (for a specific session if provided)
function sequence:error(msg, session)
    assert(self, "Must be called on a object")
    if session then
        self:removeSession(session.id)
    end
    error("Sequence " .. tostring(self) .. " error: " .. tostring(msg))
end

-- Asserts a condition in the sequence
function sequence:assert(cond, msg)
    assert(self, "Must be called on a object")
    if not cond then
        self:error(msg)
    end
end

-- Processes a message for a specific session
function sequence:process(sessionID, message)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    self:assert(message, "No message given")
    
    -- Find the session by ID
    local session = self:findSession(sessionID)
    if not session then
        self:error("Session " .. tostring(sessionID) .. " not found")
        return
    end
    
    -- Check for timeout (removes session automatically if timed out)
    if self:checkTimeout(session) then
        self:error("Session " .. tostring(sessionID) .. " has timed out", session)
        return
    end
    
    -- Reset the session timeout since we're processing a message
    session.startTime = computer.uptime()

    -- Resume the session's coroutine with the incoming message. Use pcall to catch errors.
    -- IMPORTANT: this implementation strictly assumes the coroutine returns a single TABLE
    -- containing outbound message objects (nothing else). We enforce that here.
    local results = {pcall(coroutine.resume, session.routine, message)}
    if not results[1] then
        self:error("Error resuming coroutine in session " .. tostring(sessionID) .. ": " .. tostring(results[2]), session)
        return
    end
    if not results[2] then
        self:error("Coroutine error in session " .. tostring(sessionID) .. ": " .. tostring(results[3]), session)
        return
    end

    -- Expect a single table as the coroutine return (at results[3]).
    local outbound = results[3]
    if type(outbound) ~= "table" then
        self:error("Expected coroutine to return a table of outbound messages, got " .. tostring(outbound), session)
        return
    end

    -- Validate every outbound message returned by the coroutine. Use ipairs to iterate
    -- the table in order and skip any nil/holes automatically.
    for _, msg in ipairs(outbound) do
        if not isInstanceOf(msg, class("messages/outbound")) then
            self:error("Expected outbound instance from sequence return, got " .. tostring(msg), session)
            return
        end
        if type(msg.send) ~= "function" then
            self:error("Outbound message has no send() method to deliver it", session)
            return
        end
    end

    -- Keep the returned table for inspection in the session.
    session.result = outbound
    
    -- If coroutine finished, remove the session automatically.
    if coroutine.status(session.routine) == "dead" then
        self:removeSession(session.id)
    end
    
    -- Send any responses
    if outbound then
        for _, msg in ipairs(outbound) do
            msg:send()
        end
    end
end

return sequence