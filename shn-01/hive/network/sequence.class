--[[
    SHN-01 Network Sequence Class
        This class represents a network sequence in the SHN-01 system.
        It handles the execution and management of sequences based on manifests.
        A sequence is a dialogue between two networked systems following a predefined set of steps.
]]
local sequence = newClass()

-- Creates a new sequence object based on the manifest
-- This is a static factory method - call as: sequenceClass.create(hive, protocol, manifestPath)
function sequence.create(hive, protocol, manifestPath, ...)
    assert(manifestPath, "No manifest path given")
    
    local manifest = include(manifestPath)
    assert(manifest, "Could not load manifest from " .. manifestPath)

    assert(manifest.name, "Manifest has no name")
    assert(manifest.server, "Manifest has no server defined")
    
    local sequenceFuncFactory = include(getAbsolutePath(manifest.server, file.getDir(manifestPath)))
    assert(sequenceFuncFactory, "No sequence function found for " .. manifest.name)
    assert(type(sequenceFuncFactory) == "function", "Expected sequence function factory, got " .. type(sequenceFuncFactory))
    
    -- Call the factory function to get the actual coroutine function
    -- Server functions receive hive and protocol
    local sequenceFunc = sequenceFuncFactory(hive, protocol)
    assert(type(sequenceFunc) == "function", "Expected sequence function from factory, got " .. type(sequenceFunc))
    
    -- Create sequence instance with the function
    local instance = sequence:new(
        protocol,
        string.upper(manifest.name),
        sequenceFunc,
        manifest.timeout,
        manifest.timeoutCallback,
        manifest.sequence
    )
    return instance
end

function sequence:constructor(protocol,name, func, timeout, timeoutCallback, isSequence)
    assert(protocol, "No protocol given")
    assert(name, "No sequence name given")
    assert(func, "No sequence function given")
    assert(type(func) == "function", "Invalid sequence function, expected function")
    assert(self, "Must be called on a object")
    assert(timeoutCallback == nil or type(timeoutCallback) == "function", "Invalid timeout function, expected function or nil")

    self.name = name
    self.func = func
    self.timeout = timeout or 60 -- Default timeout of 60 seconds
    self.timeoutCallback = timeoutCallback
    self.sessions = {} -- Each session has its own coroutine and state
    self.protocol = protocol
    self.isSequence = isSequence or false
end

-- Internal method to execute a coroutine and send outbound messages
function sequence:executeAndSend(routine, node, args, sessionId)
    self:assert(self, "Must be called on a object")
    
    -- Resume the coroutine with the incoming message. Use pcall to catch errors.
    local results = {pcall(coroutine.resume, routine, node, args)}
    if not results[1] then
        self:error("Error resuming coroutine: " .. tostring(results[2]))
        return false
    end
    if not results[2] then
        self:error("Coroutine error: " .. tostring(results[3]))
        return false
    end

    -- Expect a single table or nil as the coroutine return (at results[3]).
    local outbound = results[3]
    if outbound ~= nil and type(outbound) ~= "table" then
        self:error("Expected coroutine to return a table of outbound messages or nil, got " .. tostring(outbound))
        return false
    end

    -- Validate every outbound message returned by the coroutine.
    if outbound then
        for _, msg in ipairs(outbound) do
            if not isInstanceOf(msg, class("messages/outbound")) then
                self:error("Expected outbound instance from sequence return, got " .. tostring(msg))
                return false
            end
            if type(msg.send) ~= "function" then
                self:error("Outbound message has no send() method to deliver it")
                return false
            end
        end
    end
    
    -- Send any responses
    if outbound then
        for _, msg in ipairs(outbound) do
            msg:insertParameter(1, self.name)
            if sessionId then
                msg:insertParameter(2, sessionId)
            end
            msg:send()
        end
    end
    
    return true, outbound
end

-- Creates a new session for this sequence and processes the first message
function sequence:createSession(node, args)
    self:assert(self, "Must be called on a object")
    
    -- If not a sequence, just run once without session management
    if not self.isSequence then
        --debugPrint("Executing non-sequence <c=0xFF00FF>" .. self.name .. "</c> (no session)", node)
        
        -- Create a one-time coroutine and execute it
        local routine = coroutine.create(self.func)
        self:executeAndSend(routine, node, args, nil)
        
        return nil -- No session created
    end
    
    -- Generate unique session ID (counter-based, guaranteed unique)
    local sessionId = node:newSessionId()
    
    local newSession = {
        id = sessionId,
        routine = coroutine.create(self.func),
        startTime = computer.uptime(),
        result = nil,
        node = node
    }
    table.insert(self.sessions, newSession)
    
    -- Register session with the node for efficient cleanup
    if node then
        node.sessions[newSession.id] = true
    end
    
    -- Send SESSION_CREATED notification to client
    if node then
        -- Use outbound message class when node exists
        local sessionNotification = class("messages/outbound"):new(
            node,
            self.protocol,
            nil,
            "SESSION_CREATED",
            newSession.id
        )
        sessionNotification:send()
    else
        -- Send directly via modem when node doesn't exist yet (e.g., during handshake)
        local modem = getComponent("modem")
        modem.send(node.address, self.protocol.port, "SESSION_CREATED", newSession.id)
    end
    
    --debugPrint("Started new session <c=0xFFFFFF>" .. sessionId .. "</c> for sequence <c=0xFF00FF>" .. self.name .. "</c>", node)
    
    -- Process the first message to kick off the session
    self:process(newSession.id, args)
    
    return newSession.id
end

-- Processes a message for a specific session
function sequence:process(sessionID, args)
    self:assert(self, "Must be called on a object")
    
    -- Non-sequences don't use process(), they run directly in createSession
    if not self.isSequence then
        self:error("Cannot process non-sequence with session ID")
        return
    end
    
    self:assert(sessionID, "No session ID given")
    
    -- Find the session by ID
    local session = self:findSession(sessionID)
    if not session then
        self:error("Session " .. tostring(sessionID) .. " not found")
        return
    end
    
    -- Check for timeout (removes session automatically if timed out)
    if self:checkTimeout(session) then
        self:error("Session " .. tostring(sessionID) .. " has timed out", session)
        return
    end
    
    -- Reset the session timeout since we're processing a message
    session.startTime = computer.uptime()

    -- Execute the coroutine and send messages
    local success, outbound = self:executeAndSend(session.routine, session.node, args, session.id)
    if not success then
        self:removeSession(session.id)
        return
    end

    -- Keep the returned table for inspection in the session.
    session.result = outbound
    
    -- If coroutine finished, remove the session automatically.
    if coroutine.status(session.routine) == "dead" then
        debugPrint("Session <c=0xFFFFFF>" .. session.id .. "</c> ended for sequence <c=0xFF00FF>" .. self.name .. "</c>", session.node)
        self:removeSession(session.id)
    end
end

-- Finds a session by its ID
function sequence:findSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for _, session in ipairs(self.sessions) do
        if session.id == sessionID then
            return session
        end
    end
    return nil
end

-- Removes a session by its ID
function sequence:removeSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for i, session in ipairs(self.sessions) do
        if session.id == sessionID then
            -- Remove from node's session registry
            if server and server.nodes and server.nodes[session.node.address] then
                local node = server.nodes[session.node.address]
                if node.sessions then
                    node.sessions[sessionID] = nil
                end
            end
            table.remove(self.sessions, i)
            return true
        end
    end
    return false
end

-- Gets all active sessions
function sequence:getActiveSessions()
    self:assert(self, "Must be called on a object")
    
    local active = {}
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            table.insert(active, session)
        end
    end
    return active
end

-- Gets the count of sessions (total and active)
function sequence:getSessionCount()
    self:assert(self, "Must be called on a object")
    
    local total = #self.sessions
    local active = 0
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            active = active + 1
        end
    end
    return total, active
end

function sequence:__tostring()
    self:assert(self, "Must be called on a object")
    return string.format("<c=0xFFFF00>[%s]</c>", self.name:upper())
end

function sequence:checkTimeout(session)
    self:assert(self, "Must be called on a object")
    self:assert(session, "No session given")
    
    -- Skip timeout check if timeout is 0 (indefinite session)
    if self.timeout and self.timeout > 0 and computer.uptime() - session.startTime > self.timeout then
        if self.timeoutCallback then
            self.timeoutCallback(session.id)
        end
        self:removeSession(session.id)
        return true
    end
    return false
end

-- Checks all sessions for timeouts and removes timed-out sessions
function sequence:checkTimeouts()
    self:assert(self, "Must be called on a object")
    
    -- Iterate backwards to safely remove during iteration
    for i = #self.sessions, 1, -1 do
        local session = self.sessions[i]
        self:checkTimeout(session)
    end
end

-- Handles an error in the sequence (for a specific session if provided)
function sequence:error(msg, session)
    assert(self, "Must be called on a object")
    if session then
        self:removeSession(session.id)
    end
    error("Sequence " .. tostring(self) .. " error: " .. tostring(msg))
end

-- Asserts a condition in the sequence
function sequence:assert(cond, msg)
    assert(self, "Must be called on a object")
    if not cond then
        self:error(msg)
    end
end

return sequence