--[[
    SHN-01 Network Sequence Class
        This class represents a network sequence in the SHN-01 system.
        It handles the execution and management of sequences based on manifests.
        A sequence is a dialogue between two networked systems following a predefined set of steps.
]]
local sequence = newClass()

-- Creates a new sequence object based on the manifest and mode
function sequence:create(hive, protocol, manifestPath, serverMode, ...)
    assert(manifestPath, "No manifest path given")
    
    local manifest = include(manifestPath)
    assert(manifest, "Could not load manifest from " .. manifestPath)

    assert(manifest.name, "Manifest has no name")
    assert(manifest.serverClass or manifest.clientClass, "Manifest has no server or client class defined")
    assert(serverMode, "Invalid serverMode mode, expected true for server, false for client")
    assert(type(serverMode) == "boolean", "Invalid serverMode mode, expected boolean")
    assert(self, "Must be called on a object")
    local sequenceClass = nil
    if serverMode and manifest.serverClass then
        sequenceClass = class(getAbsolutePath(manifest.serverClass, file.getDir(manifestPath)))
        assert(sequenceClass, "No sequence class found for server mode " .. manifest.name)
    elseif not serverMode and manifest.clientClass then
        sequenceClass = class(getAbsolutePath(manifest.clientClass, file.getDir(manifestPath)))
        assert(sequenceClass, "No sequence class found for client mode " .. manifest.name)
    else
        error("Sequence manifest " .. manifest.name .. " no valid mode")
    end    
    return sequenceClass:new(hive, protocol, ...)
end

function sequence:constructor(name, func, timeout, timeoutCallback)
    assert(name, "No sequence name given")
    assert(func, "No sequence function given")
    assert(type(func) == "function", "Invalid sequence function, expected function")
    assert(self, "Must be called on a object")
    assert(timeoutCallback == nil or type(timeoutCallback) == "function", "Invalid timeout function, expected function or nil")

    self.name = name
    self.func = func
    self.timeout = timeout or 60 -- Default timeout of 60 seconds
    self.timeoutCallback = timeoutCallback
    self.sessions = {} -- Each session has its own coroutine and state

end

-- Creates a new session for this sequence and processes the first message
function sequence:createSession(firstMessage)
    self:assert(self, "Must be called on a object")
    
    local newSession = {
        id = crypto.sessionID(),
        routine = coroutine.create(self.func),
        startTime = os.time(),
        result = nil
    }
    table.insert(self.sessions, newSession)
    self:process(newSession.id, firstMessage)
    return newSession.id
end

-- Finds a session by its ID
function sequence:findSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for _, session in ipairs(self.sessions) do
        if session.id == sessionID then
            return session
        end
    end
    return nil
end

-- Removes a session by its ID
function sequence:removeSession(sessionID)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    
    for i, session in ipairs(self.sessions) do
        if session.id == sessionID then
            table.remove(self.sessions, i)
            return true
        end
    end
    return false
end

-- Gets all active sessions
function sequence:getActiveSessions()
    self:assert(self, "Must be called on a object")
    
    local active = {}
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            table.insert(active, session)
        end
    end
    return active
end

-- Gets the count of sessions (total and active)
function sequence:getSessionCount()
    self:assert(self, "Must be called on a object")
    
    local total = #self.sessions
    local active = 0
    for _, session in ipairs(self.sessions) do
        if coroutine.status(session.routine) ~= "dead" then
            active = active + 1
        end
    end
    return total, active
end

function sequence:__tostring()
    self:assert(self, "Must be called on a object")
    return string.format("<c=0xFFFF00>[%s]</c>", self.name:upper())
end

function sequence:checkTimeout(session)
    self:assert(self, "Must be called on a object")
    self:assert(session, "No session given")
    
    if os.time() - session.startTime > self.timeout then
        if self.timeoutCallback then
            self.timeoutCallback(session.id)
        end
        self:removeSession(session.id)
        return true
    end
    return false
end

-- Handles an error in the sequence (for a specific session if provided)
function sequence:error(msg, session)
    assert(self, "Must be called on a object")
    if session then
        self:removeSession(session.id)
    end
    error("Sequence " .. tostring(self) .. " error: " .. tostring(msg))
end

-- Asserts a condition in the sequence
function sequence:assert(cond, msg)
    assert(self, "Must be called on a object")
    if not cond then
        self:error(msg)
    end
end

-- Processes a message for a specific session
function sequence:process(sessionID, message)
    self:assert(self, "Must be called on a object")
    self:assert(sessionID, "No session ID given")
    self:assert(message, "No message given")
    
    -- Find the session by ID
    local session = self:findSession(sessionID)
    if not session then
        self:error("Session " .. tostring(sessionID) .. " not found")
        return
    end
    
    -- Check for timeout (removes session automatically if timed out)
    if self:checkTimeout(session) then
        self:error("Session " .. tostring(sessionID) .. " has timed out", session)
        return
    end
    
    -- Reset the session timeout since we're processing a message
    session.startTime = os.time()

    -- Resume the session's coroutine with the incoming message. Use pcall to catch errors.
    -- IMPORTANT: this implementation strictly assumes the coroutine returns a single TABLE
    -- containing outbound message objects (nothing else). We enforce that here.
    local results = {pcall(coroutine.resume, session.routine, message)}
    if not results[1] then
        self:error("Error resuming coroutine in session " .. tostring(sessionID) .. ": " .. tostring(results[2]), session)
        return
    end
    if not results[2] then
        self:error("Coroutine error in session " .. tostring(sessionID) .. ": " .. tostring(results[3]), session)
        return
    end

    -- Expect a single table as the coroutine return (at results[3]).
    local outbound = results[3]
    if type(outbound) ~= "table" then
        self:error("Expected coroutine to return a table of outbound messages, got " .. tostring(outbound), session)
        return
    end

    -- Validate every outbound message returned by the coroutine. Use ipairs to iterate
    -- the table in order and skip any nil/holes automatically.
    for _, msg in ipairs(outbound) do
        if not isInstanceOf(msg, class("messages/outbound")) then
            self:error("Expected outbound instance from sequence return, got " .. tostring(msg), session)
            return
        end
        if type(msg.send) ~= "function" then
            self:error("Outbound message has no send() method to deliver it", session)
            return
        end
    end

    -- Keep the returned table for inspection in the session.
    session.result = outbound
    
    -- If coroutine finished, remove the session automatically.
    if coroutine.status(session.routine) == "dead" then
        self:removeSession(session.id)
    end

    return outbound
end

return sequence