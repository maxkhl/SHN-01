--[[
    SHN-01 Network Protocol Class
        This class represents a network protocol in the SHN-01 system.
        It handles the creation and management of sessions and sequences for the protocol.
]]
local protocol = newClass()

-- Creates a new event with the given name
function protocol:constructor(server, name, port, description, sequences)
    assert(self, "Must be called on a object")
    assert(name, "No protocol name given")
    assert(port, "No protocol port given")
    assert(type(port) == "number", "Invalid protocol port, expected number")
    assert(type(sequences) == "table", "Invalid sequences, expected table")
    assert(server, "No server object given")

    self.server = server
    self.name = name
    self.description = description
    self.port = port

    -- Contains all sequences this protocol supports indexed by name
    self.sequences = {}
    for _, seq in ipairs(sequences) do
        self.sequences[seq.name] = seq
    end
    
end

function protocol:__tostring()
    assert(self, "Must be called on a object")
    return "<c=0xFFFF00>[" .. self.name .. "]</c> " .. self.description .. " on port <c=0xFFFF00>" .. self.port .. "</c>"
end

function protocol:start()
    assert(self, "Must be called on a object")
    local modem = getComponent("modem")

    -- Open the modem port for this protocol
    modem.open(self.port)

    globalEvents.onNetMessageReceived:subscribe(function(receiver, sender, port, distance, ...)
        if port == self.port then
            local message = self:createMessage(sender, self, distance, ...)
            local args = {...}
            
            -- First arg is either a sequence name (new session) or session ID (existing session)
            local identifier = args[1]
            
            if self.sequences[identifier] then
                -- This is a new sequence request - create a session
                local sequence = self.sequences[identifier]
                local sessionID = sequence:createSession(message)
                print("Started new session " .. sessionID .. " for sequence " .. identifier)
            else
                -- This should be a session ID - find which sequence owns it
                local foundSequence = nil
                for _, seq in pairs(self.sequences) do
                    if seq:findSession(identifier) then
                        foundSequence = seq
                        break
                    end
                end
                
                if foundSequence then
                    -- Process the message in the existing session
                    foundSequence:process(identifier, message)
                else
                    error("Unknown message identifier '" .. tostring(identifier) .. "' in protocol " .. self.name)
                end
            end

            if self.handleMessage then
                self:handleMessage(receiver, sender, distance, ...)
            end
        end
    end)

    print("<c=0xFF00FF>></c>" ..tostring(self))

    for name, seq in pairs(self.sequences) do
        print("<c=0xFF00FF>>></c>" .. tostring(seq))
    end
end

function protocol:createMessage(remoteAddress, protocol, distance, ...)
    assert(self, "Must be called on a object")
    return class("/shn-01/network/message"):new(remoteAddress, protocol, distance, ...)
end

return protocol