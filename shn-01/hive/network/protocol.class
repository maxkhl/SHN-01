--[[
    SHN-01 Network Protocol Class
        This class represents a network protocol in the SHN-01 system.
        It handles the creation and management of sessions and sequences for the protocol.
]]
local protocol = newClass()

-- Creates a new event with the given name
function protocol:constructor(server, name, port, description, sequences)
    assert(self, "Must be called on a object")
    assert(name, "No protocol name given")
    assert(port, "No protocol port given")
    assert(type(port) == "number", "Invalid protocol port, expected number")
    assert(type(sequences) == "table", "Invalid sequences, expected table")
    assert(server, "No server object given")

    self.server = server
    self.name = name
    self.description = description
    self.port = port

    -- Contains all sequences this protocol supports indexed by name
    self.sequences = {}
    for i, seq in ipairs(sequences) do
        self.sequences[seq.name] = seq
    end
end

function protocol:__tostring()
    assert(self, "Must be called on a object")
    return "<c=0xFFFF00>[" .. self.name .. "]</c> " .. self.description .. " on port <c=0xFFFF00>" .. self.port .. "</c>"
end

function protocol:start()
    assert(self, "Must be called on a object")
    local modem = getComponent("modem")

    -- Open the modem port for this protocol
    modem.open(self.port)

    -- Capture protocol reference locally to avoid closure issues
    local thisProtocol = self
    local thisPort = self.port
    local thisName = self.name

    globalEvents.onNetMessageReceived:subscribe(function(receiver, sender, port, distance, ...)
        if port == thisPort then
            -- Ignore messages from self (server receiving its own broadcasts)
            local modem = getComponent("modem")
            if sender == modem.address then
                return
            end

            local message = thisProtocol:createInboundMessage(sender, thisProtocol, distance, ...)
            local args = {...}
            
            -- Get node object from sender address if available            
            local node = thisProtocol.server and thisProtocol.server.nodes and thisProtocol.server.nodes[sender] or nil

            -- If no node found and this is a handshake attempt, create a temporary node
            if not node and thisName == "GATE" and args[1] == "handshake" and args[4] == thisProtocol.server.id then
                local nodeId = args[3] -- this should be the node ID in handshake message
                node = thisProtocol.server:connectNode(nodeId, sender)
                if not node then
                    console:log("<c=0xFF0000>Failed to create node for handshake from " .. sender .. " on protocol " .. thisName .. " with ID " .. nodeId .. "</c>")
                    return
                end            
            end

            if not node then
                local msgArgs = {...}
                for i = 1, #msgArgs do msgArgs[i] = tostring(msgArgs[i]) end
                console:log("<c=0xFF0000>Rejected message from unknown node " .. sender .. " on protocol " .. thisName .. "</c>\n  Message: " .. table.concat(msgArgs, ", "))
                return
            end

            if node and node.isDefective and node:isDefective() then
                local msgArgs = {...}
                for i = 1, #msgArgs do msgArgs[i] = tostring(msgArgs[i]) end
                console:log("<c=0xFF0000>Rejected message from defective node " .. node.id .. " on protocol " .. thisName .. "</c>\n  Message: " .. table.concat(msgArgs, ", "))
                return
            end

            local nodePrefix = node and ("<c=0xFFFFFF>[" .. node.shortName .. "]</c>") or ""
            
            
            -- First arg is either a sequence name (new session) or session ID (existing session)
            local sequenceName = string.upper(args[1] or "")
            local sessionID = args[2]
            args = {select(3, ...)} -- Remove identifier from args and pack into table
            
            if sequenceName == "" then
                error("No message identifier provided in protocol " .. thisName, 0, nodePrefix)
                return
            end            
            
            local sequence = thisProtocol.sequences[sequenceName]
            if sequence then
                if sessionID == nil then
                    -- This is a new sequence request - create a session

                    local sessionID = sequence:createSession(node or sender, args)
                    
                    -- Note: createSession calls process internally which sends responses
                else
                    -- This should be a session ID - find which sequence owns it                    
                    if sequence:findSession(sessionID) then
                        -- Process the message in the existing session and send responses
                        --debugPrint("Returning for session <c=0xFFFFFF>" .. tostring(sessionID) .. "</c> in sequence <c=0xFF00FF>" .. sequenceName .. "</c>", node)
                        local outbound = sequence:process(sessionID, args)
                        if outbound then
                            for _, msg in ipairs(outbound) do
                                msg:send()
                            end
                        end
                    else
                        error("No session with ID <c=0xFFFFFF>" .. tostring(sessionID) .. "</c> found in sequence <c=0xFF00FF>" .. sequenceName .. "</c> for protocol " .. thisName, 0, nodePrefix)
                    end
                end
            else
                error("Unknown sequence name '" .. tostring(sequenceName) .. "' in protocol " .. thisName, 0, nodePrefix)
            end
        end
    end)

    -- Show protocol initialization info
    debugPrint(tostring(self))
    for name, seq in pairs(self.sequences) do
        debugPrint("  > " .. tostring(seq))
    end
end

function protocol:createInboundMessage(remoteAddress, protocol, distance, ...)
    assert(self, "Must be called on a object")
    -- For inbound messages, we need to find if this node is connected
    local node = self.server and self.server.nodes and self.server.nodes[remoteAddress] or nil
    return class("messages/inbound"):new(remoteAddress, node, protocol, distance, ...)
end

function protocol:getSequenceNames()
    local names = {}
    for name, _ in pairs(self.sequences) do
        table.insert(names, name)
    end
    return names
end

return protocol