--[[
    SHN-01 Network Protocol Class
        This class represents a network protocol in the SHN-01 system.
        It handles the creation and management of sessions and sequences for the protocol.
]]
local protocol = newClass()

-- Creates a new event with the given name
function protocol:constructor(server, name, port, description, sequences)
    assert(self, "Must be called on a object")
    assert(name, "No protocol name given")
    assert(port, "No protocol port given")
    assert(type(port) == "number", "Invalid protocol port, expected number")
    assert(type(sequences) == "table", "Invalid sequences, expected table")
    assert(server, "No server object given")

    self.server = server
    self.name = name
    self.description = description
    self.port = port

    self.sessions = {}

    -- Contains all sequences this protocol supports indexed by name
    self.sequences = {}
    for _, seq in ipairs(sequences) do
        self.sequences[seq.name] = seq
    end
    
end

function protocol:__tostring()
    assert(self, "Must be called on a object")
    return "<c=0xFFFF00>[" .. self.name .. "]</c> " .. self.description .. " on port <c=0xFFFF00>" .. self.port .. "</c>"
end

function protocol:start()
    assert(self, "Must be called on a object")
    local modem = getComponent("modem")

    -- Open the modem port for this protocol
    modem.open(self.port)

    globalEvents.onNetMessageReceived:subscribe(function(receiver, sender, port, distance, ...)
        if port == self.port then
            local message = self:createMessage(sender, self, distance, ...)
            
            if self.sequences[(...)[1]] then -- message is a new sequence request
                local sequenceID = (...)[1]
                local sessionID = self:startSession(sequenceID, ...)
                if sessionID then
                    print("Started new session with ID " .. sessionID .. " for sequence " .. sequenceID)
                else
                    print("Failed to start session for sequence " .. sequenceID)
                end
            elseif self.sessions[(...)[1]] then -- message is a session request
                local sessionID = (...)[1]
                if not self.sessions[sessionID] then
                    error("No session with ID " .. sessionID .. " found in protocol " .. self.name)
                end

                -- Process the message in the session
                local status, result = self.sessions[sessionID]:process(message)
                if status == class("sequence").sequenceStatus.finished then
                    local sequence = self.sessions[sessionID]
                    self.sessions[sessionID] = nil
                    self:onSequenceFinished(sequence, result, sessionID)
                end
            else
                error("Unknown message type or sequence ID in protocol " .. self.name)
            end

            if self.handleMessage then
                self:handleMessage(receiver, sender, distance, ...)
            end
        end
    end)

    print("<c=0xFF00FF>></c>" ..tostring(self))

    for name, seq in pairs(self.sequences) do
        print("<c=0xFF00FF>>></c>" .. tostring(seq))
    end
end

function protocol:startSession(sequenceID, ...)
    assert(self, "Must be called on a object")
    assert(sequenceID, "No sequence ID given")
    if not self.sequences[sequenceID] then
        error("No sequence with ID " .. sequenceID .. " found in protocol " .. self.name)
    end

    -- Create a new session for the sequence
    local sessionID = crypto.sessionID() -- Generate a unique session ID
    local sequence = self.sequences[sequenceID]
    self.sessions[sessionID] = sequence:new(sessionID, ...)

    return sessionID
end

-- Processes a message for this protocol
function protocol:process(sessionID, ...)
    assert(self, "Must be called on a object")
    local sequence = self.sessions[sessionID]
    if not sequence then
        error("No sequence with ID " .. sessionID .. " found in protocol " .. self.name)
    end

    -- Call the sequence with the given arguments
    sequence:process(...)

    if sequence.alive == false then
        self.sessions[sessionID] = nil
    end
end

function protocol:createMessage(remoteAddress, protocol, distance, ...)
    assert(self, "Must be called on a object")
    return class("/shn-01/network/message"):new(remoteAddress, protocol, distance, ...)
end

function protocol:onSequenceFinished(sequence, result, sessionID)
    -- Can be overridden by subclasses to react to finished sequences
end

return protocol