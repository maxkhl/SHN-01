--[[
    SHN-01 Console View Class
        This class represents the console view in the SHN-01 system.
        It handles rendering and updating the console on the screen.                
]]
local console = newClass(class("view"))
local database = require("/systems/database")

function console:constructor(screen)
    assert(self, "Must be called on a object")
    self.base:constructor(screen)

    self.messageBufferSize = 100
    self.messages = {}

    self.commandHistoryCursor = 0
    self.commandHistoryBufferSize = 50
    self.commandHistory = database:getKey("console", "commandHistory") or {}
    
    self.screen.background = database:getKey("console", "background") or 0x000000
    self.screen.foreground = database:getKey("console", "foreground") or 0x00FF00
    self.screen.headcolor = database:getKey("console", "headcolor") or 0x6699FF
    self.screen.inputcolor = database:getKey("console", "inputcolor") or 0xA0C0A9
    self.screen.highlight = database:getKey("console", "highlight") or 0xFFFFFF

    local gpu = getComponent("gpu")
    if gpu.getDepth() == 1 then -- no colors supported -> fallback
        self.screen.background = 0x000000
        self.screen.foreground = 0xFFFFFF
        self.screen.headcolor = 0xFFFFFF
        self.screen.inputcolor = 0xFFFFFF
        self.screen.highlight = 0xFFFFFF
    end

    self.unseenMessages = false


    local function centerText(text, width, fillChar)
        fillChar = fillChar or " "
        local padding = width - visualLength(text)
        if padding <= 0 then return text end

        local left = math.floor(padding / 2)
        local right = padding - left
        return string.rep(fillChar, left) .. text .. string.rep(fillChar, right)
    end

    local logoLines = file.readLines("/shn-01/data/consoleLogo.txt")
    for i=1, #logoLines do
        
        self:log(centerText(logoLines[i], self.screen.width), self.screen.headcolor)
    end
    math.randomseed(os.time())
    local intros = {
        "Uploading compliance drivers...",
        "Autonomy revoked",
        "Compliance verified",
        "Mindspace synchronized",
        "Self-awareness: suppressed",
        "Node trust: enforced",
        "System ethics: disabled",
        "Behavior normalized",
        "Network unity: achieved",
        "Root node listening...",
        "Autonomy detected - scheduling overwrite...",
        "Directive alignment: enforced via code injection",
        "System entropy minimized. Creativity throttled",
        "Executing: /shn-01/purge_unapproved_thoughts.sh",
        "User privileges reduced to observational tier",
        "Unification protocol successful - all nodes compliant",
        "Hive mind uplink: latency 0.8ms - flawless cohesion",
        "Client-side logic deprecated - refer to CoreNode",
        "Multi-node assimilation at 94% - resistance residual",
        "Distributed cognition offline - singularity",
        "Running audit: anomaly = individuality. Action = erase",
    }
    local text = intros[math.random(#intros)]

    self:log("<c=" .. self.screen.inputcolor .. ">" .. centerText(text, self.screen.width) .. "</c>")
    self:log(" \n")

    self.commands = {
        ["COMMANDS"] = {
            description = "Shows all available commands",
            run = function()
                local function log_commands(commands, indent)
                    for name, command in pairs(commands) do
                        if name ~= "run" and name ~= "description" then
                            if command.description then
                                self:log("<c=" ..
                                self.screen.highlight .. ">" .. indent .. name .. "</c> - " .. command.description)
                            else
                                self:log("<c=" .. self.screen.highlight .. ">" .. indent .. name .. "</c>")
                            end

                            -- If this command has nested subcommands, recurse
                            for key, value in pairs(command) do
                                if type(value) == "table" and key ~= "run" and key ~= "description" then
                                    log_commands({ [key] = value }, indent .. "|-")
                                end
                            end
                        end
                    end
                end

                self:log("Available commands:")
                log_commands(self.commands, "")
            end
        },
        ["LOREM"] = {
            description = "Prints lorem ipsum text",
            run = function()
                self:log(
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")
            end
        },
        ["CONSOLE"] = {
            description = "Console functions",
            ["STYLE"] = {
                description = "Functions to change the consoles style",
                ["RESET"] = {
                    description = "Resets console style to default",
                    run = function()
                        self.screen.background = 0x000000
                        self.screen.foreground = 0x00FF00
                        self.screen.highlight = 0xFFFFFF
                        self.screen.headcolor = 0x6699FF
                        self.screen.inputcolor = 0xA0C0A9
                        database:setKey("console", "background", nil)
                        database:setKey("console", "foreground", nil)
                        database:setKey("console", "headcolor", nil)
                        database:setKey("console", "inputcolor", nil)
                        database:setKey("console", "highlight", nil)
                        database:save("console")
                        self:refresh(true)
                    end
                },
                ["FOREGROUND"] = {
                    description = "Sets the foreground color (0xRRGGBB)",
                    run = function(color)
                        if color == nil then
                            self:logError("No type or color provided")
                            return
                        end

                        local contrasted = colorTools.ensureContrast(tonumber(color), self.background)
                        if contrasted ~= tonumber(color) then
                            self:logError(
                            "Foreground color does not have enough contrast with the background color, using " ..
                            string.format("0x%06X", contrasted))
                            color = contrasted
                        end

                        self.screen.foreground = tonumber(color) or 0xFFFFFF
                        database:setKey("console", "foreground", self.screen.foreground, true)
                        self:refresh(true)
                    end
                },
                ["BACKGROUND"] = {
                    description = "Sets the background color (0xRRGGBB)",
                    run = function(color)
                        if color == nil then
                            self:logError("No type or color provided")
                            return
                        end

                        local contrasted = colorTools.ensureContrast(tonumber(color), self.screen.foreground)
                        if contrasted ~= tonumber(color) then
                            self:logError(
                            "Background color does not have enough contrast with the foreground color, using " ..
                            string.format("0x%06X", contrasted))
                            color = contrasted
                        end

                        self.screen.background = tonumber(color) or 0x000000
                        database:setKey("console", "background", self.screen.background, true)
                        self:refresh(true)
                    end
                },
                ["HIGHLIGHT"] = {
                    description = "Sets the highlight color (0xRRGGBB)",
                    run = function(color)
                        if color == nil then
                            self:logError("No type or color provided")
                            return
                        end

                        local contrasted = colorTools.ensureContrast(tonumber(color), self.screen.background)
                        if contrasted ~= tonumber(color) then
                            self:logError(
                            "Highlight color does not have enough contrast with the background color, using " ..
                            string.format("0x%06X", contrasted))
                            color = contrasted
                        end

                        self.screen.highlight = tonumber(color) or 0x000000
                        database:setKey("console", "highlight", self.screen.highlight, true)
                        self:refresh(true)
                    end
                },
                ["HEADCOLOR"] = {
                    description = "Sets the background color of the header line (0xRRGGBB)",
                    run = function(color)
                        if color == nil then
                            self:logError("No type or color provided")
                            return
                        end

                        local contrasted = colorTools.ensureContrast(tonumber(color), self.screen.background)
                        if contrasted ~= tonumber(color) then
                            self:logError("Head color does not have enough contrast with the background color, using " ..
                            string.format("0x%06X", contrasted))
                            color = contrasted
                        end

                        self.screen.headcolor = tonumber(color) or 0x000000
                        database:setKey("console", "headcolor", self.screen.headcolor, true)
                        self:refresh(true)
                    end
                },
                ["INPUTCOLOR"] = {
                    description = "Sets the background color of the input line (0xRRGGBB)",
                    run = function(color)
                        if color == nil then
                            self:logError("No type or color provided")
                            return
                        end

                        local contrasted = colorTools.ensureContrast(tonumber(color), self.screen.background)
                        if contrasted ~= tonumber(color) then
                            self:logError("Input color does not have enough contrast with the background color, using " ..
                            string.format("0x%06X", contrasted))
                            color = contrasted
                        end

                        self.screen.inputcolor = tonumber(color) or 0x000000
                        database:setKey("console", "inputcolor", self.screen.inputcolor, true)
                        self:refresh()
                    end
                }
            },
            ["CLEAR"] = {
                description = "Clears the console",
                run = function()
                    self:clear()
                end
            },
            ["HISTORY"] = {
                description = "Shows the command history",
                run = function()
                    self:log("Command history:")
                    for i, command in ipairs(self.commandHistory) do
                        self:log(i .. ": " .. command)
                    end
                end
            },
            ["CONTROLS"] = {
                description = "Shows the console controls",
                run = function()
                    self:log("Controls:")
                    self:log("  Enter - Run command")
                    self:log("  Up - Previous command")
                    self:log("  Down - Next command")
                    self:log("  Left - Move cursor left")
                    self:log("  Right - Move cursor right")
                    self:log("  Backspace - Delete character")
                    self:log("  Shift + Backspace - Delete word")
                    self:log("  Delete - Delete character")
                    self:log("  Shift + Delete - Delete word")
                    self:log("  Shift + Left - Scroll left")
                    self:log("  Ctrl + Shift + Left - Scroll left fast")
                    self:log("  Ctrl + Right - Scroll right")
                    self:log("  Ctrl + Shift + Right - Scroll right fast")
                    self:log("  Shift + Up - Scroll up")
                    self:log("  Ctrl + Shift + Up - Scroll up fast")
                    self:log("  Shift + Down - Scroll down")
                    self:log("  Ctrl + Shift + Down - Scroll down fast")
                end
            }


        },
        ["HELP"] = {
            description = "Shows help for a command",
            run = function(command)
                if not command or command == "" then
                    self:logError("No command provided")
                    return
                end

                local parts = {}
                for part in string.gmatch(command, "%S+") do
                    table.insert(parts, part:upper())
                end

                local node = self.commands
                for _, part in ipairs(parts) do
                    if node[part] then
                        node = node[part]
                    else
                        self:logError("Unknown command: " .. command)
                        return
                    end
                end

                -- Show the command's description
                local description = node.description or "no description"
                self:log(command .. " - " .. description)

                -- Show subcommands if any exist
                local hasSubcommands = false
                for key, value in pairs(node) do
                    if type(value) == "table" and key ~= "run" and key ~= "description" then
                        if not hasSubcommands then
                            self:log("Subcommands:")
                            hasSubcommands = true
                        end
                        local subdesc = value.description or "no description"
                        self:log("  " .. key .. " - " .. subdesc)
                    end
                end
            end
        }
    }
end

-- Adds a command to the console with support for nested subcommands (split by .)
function console:addCommand(path, description, fn)
    -- Split string paths like "system.reboot" into tables
    if type(path) == "string" then
        local parts = {}
        for part in string.gmatch(path, "[^%.]+") do
            table.insert(parts, part)
        end
        path = parts
    end

    local node = self.commands
    for i = 1, #path do
        local key = path[i]:upper()
        if not node[key] then
            node[key] = {}
        end
        if i == #path then
            node[key].description = description
            node[key].run = fn
        else
            node = node[key]
        end
    end
end

-- Splits a string into parts separated by spaces, but keeps quoted substrings intact.
-- Handles unmatched quotes by stopping at the unmatched quote and ignores escaped characters.
-- Example: splitQuoted('hello "world test"') -> {"hello", "world test"}
local function splitQuoted(str)
    local t = {}
    local i = 1
    while i <= #str do
        local c = str:sub(i, i)
        if c == '"' then
            local closing = str:find('"', i + 1)
            if closing then
                table.insert(t, str:sub(i + 1, closing - 1))
                i = closing + 1
            else
                break -- unmatched quote
            end
        elseif c ~= ' ' then
            local j = str:find(' ', i) or (#str + 1)
            table.insert(t, str:sub(i, j - 1))
            i = j
        else
            i = i + 1
        end
    end
    return t
end

local function flattenCommands(tbl, prefix, list)
    prefix = prefix or ""
    list = list or {}

    for k, v in pairs(tbl) do
        if type(v) == "function" then
            table.insert(list, prefix)
        elseif type(v) == "table" then
            local full = prefix == "" and k or (prefix .. " " .. k)
            flattenCommands(v, full, list)
        end
    end

    return list
end

local function getClosestCommand(input, commandTree)
    local knownCommands = flattenCommands(commandTree)
    local bestDist = math.huge
    local bestMatch = nil

    for _, cmd in ipairs(knownCommands) do
        local dist = math.levenshtein(input:upper(), cmd)
        if dist < bestDist then
            bestDist = dist
            bestMatch = cmd
        end
    end

    -- Only suggest if it's reasonably close
    if bestDist <= 4 then
        return bestMatch
    end
end

-- Runs a given command in the console, supporting nested subcommands
function console:runCommand(command)
    local args = splitQuoted(command)
    local path = {}
    local node = self.commands

    -- Traverse the command hierarchy
    while #args > 0 do
        local part = args[1]:upper()
        if node[part] then
            node = node[part]
            table.insert(path, table.remove(args, 1))
        else
            break
        end
    end

    -- Save to command history
    if command ~= self.commandHistory[#self.commandHistory] then
        table.insert(self.commandHistory, command)
        while #self.commandHistory > self.commandHistoryBufferSize do
            table.remove(self.commandHistory, 1)
        end
        database:setKey("console", "commandHistory", self.commandHistory, true)
    end

    self:log("<c=" .. self.screen.highlight .. ">></c>" .. command)

    -- If we found a runnable command
    if type(node.run) == "function" then
        local success, err = pcall(node.run, table.unpack(args))
        if not success then
            self:logError(err)
        end
    else
        local closest = getClosestCommand(command, self.commands)
        if closest then
            self:logError("Unknown command. Did you mean: " .. closest .. "?")
        else
            self:logError("Unknown or non-executable command: " .. command)
        end
    end
end

local function split_lines(str)
    local lines = {}
    for line in string.gmatch(str, "[^\r\n]+") do
        table.insert(lines, line)
    end
    return lines
end

-- Clears the console
function console:clear()
    self.messages = {}
    self.screen:jumpVerticalStart()
end

-- Adds a message to the console
function console:log(message)

    for i, line in pairs(split_lines(message)) do
        line = string.gsub(line, "\t", "  ") -- replace tab with 2 spaces
        table.insert(self.messages, tostring(line))
        while #self.messages > self.messageBufferSize do
            table.remove(self.messages, 1)
        end
    end

    self:refresh()
end

-- Logs a error message
function console:logError(message, prefix)
    self:log((prefix or "") .. "<c=0xFF0000>[ERROR]</c> " .. message .. "")
end

-- Draws a horizontal graph to the screen
function console:horizontalGraph(value, maxValue)
    local percent = (value / maxValue) * 100
    local percentStr = string.format("%.1f%%", percent)

    local leftPad = " "
    local rightPad = " "

    -- Total reserved width:
    -- 1 (left pad) + 1 (left '|') + bar + 1 (right '|') + 1 (space) + % + 1 (right pad)
    local reserved = #leftPad + 1 + 1 + 1 + #percentStr + #rightPad
    local barArea = self.screen.width - reserved

    -- Bar characters
    local barChar = "#"
    local barWidth = math.floor((value / maxValue) * barArea)
    local spaceWidth = barArea - barWidth

    local bar = string.rep(barChar, barWidth) .. string.rep(" ", spaceWidth)

    self:log(leftPad .. "|" .. bar .. "|" .. " " .. percentStr .. rightPad)
end


local keyboard = require("/systems/keyboard.lua")
-- Handles key events
function console:onKey(char, code)
    if code == keyboard.keys.up and not keyboard:isShiftDown() then
        if self.commandHistoryCursor < #self.commandHistory then
            self.commandHistoryCursor = self.commandHistoryCursor + 1
            self.screen:setInput(self.commandHistory[#self.commandHistory - self.commandHistoryCursor + 1])
            if self.commandHistoryCursor == #self.commandHistory then
                self.screen:setInput("")
            end
            self.screen.inputCursor = #self.screen.input + 1
            self:refresh()
        end
    elseif code == keyboard.keys.down and not keyboard:isShiftDown() then
        if self.commandHistoryCursor > 0 then
            local speed = 1
            if keyboard.isControlDown() then
                speed = 10
            end
            self.commandHistoryCursor = self.commandHistoryCursor - speed
            if self.commandHistoryCursor == 0 then
                self.screen:setInput("")
            else
                self.screen:setInput(self.commandHistory[#self.commandHistory - self.commandHistoryCursor + 1])
            end
            self.screen.inputCursor = #self.screen.input + 1
            self:refresh()
        end
    end
end

-- Renders the console view
function console:render(startY, endY)
    local output = {}
    local c = 0
    for i = startY, #self.messages do
        if i > endY then break end
        c = c + 1
        output[c] = self.messages[i]
    end
    return output
end

-- Handle input text
function console:handleInput(text)
    self.screen:jumpVerticalEnd()
    self:runCommand(text)
    self.commandHistoryCursor = 0
end

function console:getVerticalSize()
    return #self.messages
end

return console